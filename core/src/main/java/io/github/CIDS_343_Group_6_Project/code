package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.audio.Music;
import com.badlogic.gdx.audio.Sound;
import com.badlogic.gdx.graphics.Color;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.MathUtils;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.utils.Array;
import com.badlogic.gdx.utils.ScreenUtils;
import com.badlogic.gdx.utils.viewport.FitViewport;

/** An abstract class to represent all characters in the game.
 * it is a child of the Entity class
 *
 *
 */
public class Character extends Entity{
    /**A basic constructor to make a Character with no parameters
     *
     */
    // Constructors
    public Character(Vector2 pos, TextureRegion texture, float width, float height){
        super(new Vector2(pos.x, pos.y), texture, width, height);
        hitBox.setX(pos.x);
        hitBox.setY(pos.y);
    }

    // character states
    /** Character states that show the current state a character is in
     * {@code @boolean} controllable: is the character controllable?
     * {@code @boolean} alive: is the Character alive?
     * {@code @boolean} dead: is the Character dead? (opposite of alive)
     * {@code @boolean} hostile: is the Character hostile to the player?
     */
    private boolean controllable = false;
    private boolean alive = true;
    private boolean dead = false;
    private boolean hostile = false;

    // attributes
    /** Basic Attributes for all Characters
     * {@code @String} name: the name of the Character
     * {@code @int} character_health: how much health the Character has
     * {@code @int} character_Strength: how much strength the Character has
     * {@code @int} character_magic: how good at magic is the Character
     * {@code @int} character_intelligence: how smart is the Character
     */
    public String name;
    private int character_health;
    private int character_Strength;
    private int character_magic;
    private int character_intelligence;

    //Rectangle
    /**
     * for hit detection
     */
    private Rectangle hitBox = new Rectangle();
    private HitDetector hitDetector = new HitDetector();



    // getters ---------------------------------------------------------------
    //------------------------------------------------------------------------

    /** state getters
     * Getter for controllabe
     * @return controllable
     */
    public boolean getControllable(){
        return controllable;
    }

    /**
     * Getter for alive
     * @return alive
     */
    public boolean getAlive(){
        return alive;
    }

    /**
     * getter for dead
     * @return dead
     */
    public boolean getDead(){
        return dead;
    }

    /**
     * getter for hostile
     * @return hostile
     */
    public boolean getHostile(){
        return hostile;
    }

    /** Attribute getters
     * getter for character_health
     * @return
     */
    public int getCharacterHealth(){
        return character_health;
    }

    /**
     * getter for character_strength
     * @return character_Strength
     */
    public int getCharacterStrength(){
        return character_Strength;
    }

    /**
     * getter for character magic
     * @return character_magic
     */
    public int getCharacterMagic(){
        return character_magic;
    }

    /**
     * getter for character intelligence
     * @return character_intelligence
     */
    public int getCharacterIntelligence(){
        return character_intelligence;
    }

    /**
     * getter for name
     * @return name
     */
    public String getName(){
        return name;
    }
    // Setters ---------------------------------------------------------------
    //------------------------------------------------------------------------

    /**
     * setter for controlable
     * @param controllable
     */
    public void setControllable(boolean controllable){
        this.controllable = controllable;
    }

    /** setter for alive
     *
     * @param alive
     */
    public void setAlive(boolean alive){
        this.alive = alive;
    }

    /**
     * setter for dead
     * @param dead
     */
    public void setDead(boolean dead){
        this.dead = dead;
    }

    /**
     * setter for hostile
     * @param hostile
     */
    public void setHostile(boolean hostile){
        this.hostile = hostile;
    }

    /**
     * setter for character health
     * @param health
     */
    public void setCharacterHealth(int health){
        this.character_health = health;
    }

    /**
     * setter for characterstrength
     * @param strength
     */
    public void setCharacterStrength(int strength){
        this.character_Strength = strength;
    }

    /**
     * setter for character magic
     * @param magic
     */
    public void setCharacterMagic(int magic){
        this.character_magic = magic;
    }

    /**
     * setter for character intelligence
     * @param intelligence
     */
    public void setCharacterIntelligence(int intelligence){
        this.character_intelligence = intelligence;
    }

    /**
     * setter for name
     * @param name
     */
    public void setName(String name){
        this.name = name;
    }

}
package io.github.CIDS_343_Group_6_Project;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;

public class Control extends InputAdapter implements InputProcessor {


    // CAMERA
    OrthographicCamera camera;

    // DIRECTIONS
    private boolean up;
    private boolean down;
    private boolean left;
    private boolean right;

    // MOUSE
    private boolean  LMB;
    private boolean  RMB;
    private boolean  processed_click;
    private Vector2  mouse_click_pos = new Vector2();
    private Vector2  map_click_pos = new Vector2();

    // DEBUG
    private boolean debug;

    // SCREEN
    private int screen_width;
    private int screen_height;

    //------------Getter-----------------------------------------------------
    //-----------------------------------------------------------------------
    public boolean getUp (){
        return up;
    }
    public boolean getDown (){
        return down;
    }
    public boolean getLeft (){
        return left;
    }
    public boolean getRight (){
        return right;
    }
    public boolean getLMB (){
        return LMB;
    }
    public boolean getRMB (){
        return RMB;
    }
    public boolean getProcessed_click (){
        return processed_click;
    }
    public Vector2 getmouse_click_pos (){
        return mouse_click_pos;
    }
    public Vector2 getmap_click_pos (){
        return map_click_pos;
    }
    public boolean getDebug (){
        return debug;
    }
    public int getScreen_width (){
        return screen_width;
    }
    public int getScreen_height (){
        return screen_height;
    }
    //------------Setter-----------------------------------------------------
    //-----------------------------------------------------------------------
    public void setUp ( boolean up ){
        this.up = up;
    }
    public void setDown (boolean down){
        this.down = down;
    }
    public void setLeft ( boolean left ){
        this.left = left;
    }
    public void setRight (boolean right){
            this.right = right;
    }
    public void setLMB (boolean LMB){
        this.LMB = LMB;
    }
    public void setRMB (boolean RMB){
        this.RMB = RMB;
    }
    public void setProcessed_click (boolean processed_click){
        this.processed_click = processed_click;
    }
    public void getmouse_click_pos ( Vector2 pos ){
        this.mouse_click_pos = pos;
    }
    public void getmap_click_pos ( Vector2 pos ){
        this.map_click_pos = pos;
    }
    public void setDebug ( boolean debug ){
        this.debug = debug;
    }
    public void setScreen_width ( int screen_width ){
        this.screen_width = screen_width;
    }
    public void setScreen_height ( int screen_height ){
        this.screen_height = screen_height;
    }

    public Control(int screen_width, int screen_height, OrthographicCamera camera){
        this.camera = camera;
        this.screen_width = screen_width;
        this.screen_height = screen_height;
    }

    private void setMouseClickedPos(int screenX, int screenY){
        // Set mouse position (flip screen Y)
        mouse_click_pos.set(screenX, screen_height - screenY);
        map_click_pos.set(get_map_coords(mouse_click_pos));
    }

    public Vector2 get_map_coords(Vector2 mouse_coords){
        Vector3 v3 = new Vector3(mouse_coords.x, screen_height - mouse_coords.y, 0);
        this.camera.unproject(v3);
        return new Vector2(v3.x,v3.y);
    }

    @Override
    public boolean keyDown(int keycode) {
        switch (keycode) {
            case Keys.DOWN:
                down = true;
                break;
            case Keys.UP:
                up = true;
                break;
            case Keys.LEFT:
                left = true;
                break;
            case Keys.RIGHT:
                right = true;
                break;
            case Keys.W:
                up = true;
                break;
            case Keys.A:
                left = true;
                break;
            case Keys.S:
                down = true;
                break;
            case Keys.D:
                right = true;
                break;
        }
        return false;
    }

    @Override
    public boolean keyUp(int keycode) {
        switch (keycode) {
            case Keys.DOWN:
                down = false;
                break;
            case Keys.UP:
                up = false;
                break;
            case Keys.LEFT:
                left = false;
                break;
            case Keys.RIGHT:
                right = false;
                break;
            case Keys.W:
                up = false;
                break;
            case Keys.A:
                left = false;
                break;
            case Keys.S:
                down = false;
                break;
            case Keys.D:
                right = false;
                break;
            case Keys.ESCAPE:
                Gdx.app.exit();
                break;
            case Keys.BACKSPACE:
                debug = !debug;
                break;
        }
        return false;
    }

    @Override
    public boolean keyTyped(char character) {
        return false;
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
        if(pointer == 0 && button == 0){
            LMB = true;
        } else if (pointer == 0 && button == 0){
            RMB = true;
        }

        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
        if(pointer == 0 && button == 0){
            LMB = false;
            processed_click = false;
        } else if (pointer == 0 && button == 0){
            RMB = false;
        }

        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {
        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
        return false;
    }



}
/**
Notes on how to use class
-- from tutorial game on lib gdx with this class
-- Integration with this class in the driver for tutorial game
if (keyPress.getRight()) {
    bucketSprite.translateX(speed * delta);
    }
    private void input() {

        float speed = 4f;
        float delta = Gdx.graphics.getDeltaTime();
        //Gdx.input.isKeyPressed(Input.Keys.RIGHT)
        if (keyPress.getRight()) {
            bucketSprite.translateX(speed * delta);

            //Gdx.input.isKeyPressed((Keys.LEFT))
        } else if (keyPress.getLeft()) {
            bucketSprite.translateX((-speed * delta));
        }
        else if (keyPress.getUp()){
            bucketSprite.translateY(speed * delta);
        }
        else if (keyPress.getDown()){
            bucketSprite.translateY((-speed * delta));
        }
        * did not get integrated
        if (Gdx.input.isTouched()) {
            touchPos.set(Gdx.input.getX(), Gdx.input.getY());
            viewport.unproject(touchPos);
            bucketSprite.setCenterX(touchPos.x);
        }
    }
 */
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.ApplicationListener;
import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.GL20;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.Sprite;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.viewport.FitViewport;
import com.badlogic.gdx.utils.Array;

public class Driver implements ApplicationListener {
    private SpriteBatch spriteBatch;
    private OrthographicCamera camera;
    private FitViewport viewport;

    private Texture bucketTexture;
    private Sprite bucketSprite;
    private Vector2 touchPos;
    private Array<Sprite> dropSprites;
    private Rectangle bucketRectangle;
    private Rectangle dropRectangle;

    @Override
    public void create() {
        camera = new OrthographicCamera();
        viewport = new FitViewport(8, 5, camera); // World units
        spriteBatch = new SpriteBatch();

        bucketTexture = new Texture("bucket.png");
        bucketSprite = new Sprite(bucketTexture);
        bucketSprite.setSize(1, 1); // 1x1 world unit

        touchPos = new Vector2();
        dropSprites = new Array<>();
        bucketRectangle = new Rectangle();
        dropRectangle = new Rectangle();
    }

    @Override
    public void resize(int width, int height) {
        viewport.update(width, height, true);
    }

    @Override
    public void render() {
        input();
        logic();
        draw();
    }

    private void input() {
// Your original input handling here (e.g., touch to move bucket)
    }

    private void logic() {
// Your original game logic here (e.g., spawn and move raindrops)
    }

    private void draw() {
        Gdx.gl.glClearColor(0, 0, 0, 1);
        Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT);

        camera.update();
        spriteBatch.setProjectionMatrix(camera.combined);

        spriteBatch.begin();
        bucketSprite.draw(spriteBatch);
// draw raindrops, etc. here
        spriteBatch.end();
    }

    @Override
    public void pause() {}

    @Override
    public void resume() {}

    @Override
    public void dispose() {
        spriteBatch.dispose();
        bucketTexture.dispose();
// Dispose any other textures if needed
    }
}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;

/**
 * Enemy class under NPC
 */
public class Enemy extends NPC{

    /**
     * constructor for Enemy class
     * @param enemy_name
     * @param enemy_health
     * @param enemy_magic
     * @param enemy_intelligence
     */
    public Enemy(Vector2 pos, TextureRegion texture, float width, float height, String enemy_name, int enemy_health, int enemy_magic, int enemy_intelligence ){
        super(new Vector2(pos.x, pos.y), texture, width, height);
        this.setControllable(false);
        this.setName(enemy_name);
        this.setCharacterHealth(enemy_health);
        this.setCharacterMagic(enemy_magic);
        this.setCharacterIntelligence(enemy_intelligence);
    }
}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.SpriteBatch;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;

/**
 * An abstract class to represent the fundamentals of an entity which most elements of the game will consist of
 * @author Patrick Swedenborg
 */
public abstract class Entity {
    private Vector2 pos;
    private TextureRegion texture;
    private float width;
    private float height;

    /**
     * A basic constructor which will be superimposed on following child classes
     * @param pos a vector representing position both x and y
     * @param texture the texture of the entity
     * @param width the width represented as a float
     * @param height the height represented as a float
     */
    public Entity(Vector2 pos, TextureRegion texture, float width, float height) {
        this.pos = pos;
        this.texture = texture;
        this.width = width;
        this.height = height;
    }

    /**
     * A basic draw method to put the instance on the screen
     * @param batch the spritebatch used to visualize the entity
     */
    public void draw(SpriteBatch batch) {
        batch.draw(texture, pos.x, pos.y, width, height);
    }

    /**
     * Getter for pos attribute
     * @return pos
     */
    public Vector2 getPos() {
        return pos;
    }

    /**
     * Getter for texture attribute
     * @return texture
     */
    public TextureRegion getTexture() {
        return texture;
    }

    /**
     * Getter for width attribute
     * @return width
     */
    public float getWidth() {
        return width;
    }

    /**
     * Getter for height attribute
     * @return height
     */
    public float getHeight() {
        return height;
    }

    /**
     * Setter for pos attribute
     * @param pos a vector representing the new position
     */
    public void setPos(Vector2 pos) {
        this.pos = pos;
    }

    /**
     * Setter for texture attribute
     * @param texture the new texture for the entity
     */
    public void setTexture(TextureRegion texture) {
        this.texture = texture;
    }

    /**
     * Setter for width attribute
     * @param width the new width represented as a float
     */
    public void setWidth(float width) {
        this.width = width;
    }

    /**
     * Setter for height attribute
     * @param height the new height represented as a float
     */
    public void setHeight(float height) {
        this.height = height;
    }
}
package io.github.CIDS_343_Group_6_Project;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;

public class Enums {

    private static TextureRegion[][] getTileSet() {
        Texture tileMap = new Texture(Gdx.files.internal("tileset.png"));
        TextureRegion[][] textures = new TextureRegion[32][32];
        for(int i = 0; i < 32; i++) {
            for(int j = 0; j< 32; j++) {
                textures[i][j] = new TextureRegion(tileMap, i * 8, j * 8 , 8,  8);
            }
        }
        return textures;
    }

    public static final TextureRegion[][] textures = getTileSet();

    public enum TILETYPE {

        GRASS   (textures[1][0]),
        WATER   (textures[1][14]);

        private final TextureRegion texture;

        TILETYPE(TextureRegion texture) {
            this.texture = texture;
        }

        public TextureRegion getValue() {
            return texture;
        }


    }

}
package io.github.CIDS_343_Group_6_Project;
import com.badlogic.gdx.math.Rectangle;
import map.Tile;
import org.w3c.dom.css.Rect;

public class HitDetector {
    private boolean isHit;

    /** Constructor for making object
     *
     */
    // Constructor ----------------------------------------------------------
    public HitDetector(){
        isHit = false;
    }


    /**
     * Getter and settor for checking to see of two objects are hitting
     * it sets isHit to true or false depending on if two rectangles are
     * hitting if they overlap
     * then returns what isHit is set to.
     * @param rect1
     * @param rect2
     */
    public boolean checkIfHit(Rectangle rect1, Rectangle rect2){
        if(rect1.overlaps(rect2)){
            isHit = true;
        } else {
            isHit = false;
        }
        return isHit;
    }


package io.github.CIDS_343_Group_6_Project;

import map.Chunk;
import map.EZChunk;
import map.Tile;

public class Movement {
    Character character;
    Chunk chunk;
    Tile[][] tiles;

    public Movement(Character character, EZChunk chunk) {
        this.character = character;
        this.chunk = chunk;
        this.tiles = chunk.getTiles();
    }

    public boolean isMoveValid(String direction) {
        int col = (int) Math.ceil(character.getPos().x / (80/3f));
        int row = (int) Math.ceil(character.getPos().y / (80/3f));

        Tile tile1;
        Tile tile2;
        switch (direction) {
            case "up right":
                tile1 = tiles[row + 1][col];
                tile2 = tiles[row][col + 1];
                return tile1.getCode().equals("1") && tile2.getCode().equals("1");

            case "up left":
                tile1 = tiles[row + 1][col];
                tile2 = tiles[row][col - 1];
                return tile1.getCode().equals("1") && tile2.getCode().equals("1");

            case "up":
                tile1 = tiles[row + 1][col];
                return tile1.getCode().equals("1");

            case "down right":
                tile1 = tiles[row - 1][col];
                tile2 = tiles[row][col + 1];
                return tile1.getCode().equals("1") && tile2.getCode().equals("1");

            case "down left":
                tile1 = tiles[row - 1][col];
                tile2 = tiles[row][col - 1];
                return tile1.getCode().equals("1") && tile2.getCode().equals("1");

            case "down":
                tile1 = tiles[row - 1][col];
                return tile1.getCode().equals("1");

            case "right":
                tile1 = tiles[row][col + 1];
                return tile1.getCode().equals("1");

            case "left":
                tile1 = tiles[row][col - 1];
                return tile1.getCode().equals("1");

            default:
                return false;
        }
    }
}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;


/**
 * Abstract class for a non-playable characters
 * child of character class
 */
public class NPC extends Character{

    NPC(Vector2 pos, TextureRegion texture, float width, float height) {
        super(new Vector2(pos.x, pos.y), texture, width, height);
    }

}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;


/**
 * Abstract class for a non-playable characters
 * child of character class
 */
public class NPC extends Character{

    NPC(Vector2 pos, TextureRegion texture, float width, float height) {
        super(new Vector2(pos.x, pos.y), texture, width, height);
    }

}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;

/**
 * passive characters class under NPC
 * may be traders, pedestrians, etc
 */
public class Passive_Life extends NPC{

    /**
     * Constructor for Passive_Life class
     * @param life_name
     * @param life_health
     * @param life_magic
     * @param life_intelligence
     */
    public Passive_Life(Vector2 pos, TextureRegion texture, float width, float height, String life_name, int life_health, int life_magic, int life_intelligence ){
        super(new Vector2(pos.x, pos.y), texture, width, height);
        this.setControllable(false);
        this.setName(life_name);
        this.setCharacterHealth(life_health);
        this.setCharacterMagic(life_magic);
        this.setCharacterIntelligence(life_intelligence);
    }
}
package io.github.CIDS_343_Group_6_Project;

import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;

/** Player class under character
 *
 */
public class Player extends Character{
    // Data Fields
    // test texture
    /** player texture
     * currently a placeholder, may not integrate with driver though
     */
    static Texture playerTexture = new Texture("kiryu-chan - Copy.png");

    //Constructors

    /**
     * constructor for making a player object
     * @param player_name
     * set Controllable from character parent to true
     */
    public Player(Vector2 pos, TextureRegion texture, float width, float height, String player_name){
        super(new Vector2(pos.x, pos.y), texture, width, height);
        this.name = player_name;
        this.setControllable(true);
    }


    // getters

    /**
     * getter for player texture
     * @return playerTexture
     */
    public static Texture getPlayerTexture(){
        return playerTexture;
    }




}
package io.github.CIDS_343_Group_6_Project;
public abstract class Prop {
    protected String name;
    protected boolean isInteractive;
    protected boolean isDestroyed;
    protected int x, y; // position
    protected String description;

    public Prop(String name, boolean isInteractive, int x, int y, String description) {
        this.name = name;
        this.isInteractive = isInteractive;
        this.isDestroyed = false;
        this.x = x;
        this.y = y;
        this.description = description;
    }

    public abstract void interact();

    public int getX() { return x; }
    public int getY() { return y; }
    public String getDescription() { return description; }
}





}



package io.github.CIDS_343_Group_6_Project;

public class LevelManager {
    private static int level = 1;

    public static int getLevel() {
        return level;
    }

    public static void levelUp() {
        level++;
        System.out.println("Level increased to " + level);
    }

    public static void applyLevelToEnemy(Character enemy) {
        if (enemy instanceof Enemy) {
            enemy.setCharacterStrength(level * 2); // Example: scale strength
            enemy.setCharacterHealth(level * 10); // Example: scale health
            System.out.println(enemy.getName() + " scaled to level " + level);
        }
    }
}
package io.github.CIDS_343_Group_6_Project;

import javax.swing.*;

public class PauseMenu {
    private static JFrame frame;

    public static void show() {
        if (frame != null && frame.isVisible()) return;

        frame = new JFrame("Game Paused");
        JLabel label = new JLabel("Game is Paused", SwingConstants.CENTER);
        frame.add(label);
        frame.setSize(200, 100);
        frame.setLocationRelativeTo(null);
        frame.setAlwaysOnTop(true);
        frame.setVisible(true);
    }

    public static void hide() {
        if (frame != null) {
            frame.setVisible(false);
            frame.dispose();
        }
    }
}
package io.github.CIDS_343_Group_6_Project;

public class PauseManager {
    private static boolean paused = false;

    public static boolean isPaused() {
        return paused;
    }

    public static void togglePause() {
        paused = !paused;
        if (paused) {
            PauseMenu.show();
        } else {
            PauseMenu.hide();
        }
        System.out.println(paused ? "Game Paused" : "Game Resumed");
    }

    public static void setPaused(boolean state) {
        paused = state;
    }
}
package io.github.CIDS_343_Group_6_Project;

public class Gamestate {
    public enum GameState{
        Playing,
        Paused,
    }
}
package io.github.CIDS_343_Group_6_Project;


import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.InputAdapter;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.Input.Keys;
import com.badlogic.gdx.graphics.OrthographicCamera;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.math.Vector3;

public class Control extends InputAdapter implements InputProcessor {


    // CAMERA
    OrthographicCamera camera;

    // DIRECTIONS
    private boolean up;
    private boolean down;
    private boolean left;
    private boolean right;

    // MOUSE
    private boolean  LMB;
    private boolean  RMB;
    private boolean  processed_click;
    private Vector2  mouse_click_pos = new Vector2();
    private Vector2  map_click_pos = new Vector2();

    // DEBUG
    private boolean debug;

    // SCREEN
    private int screen_width;
    private int screen_height;

    //------------Getter-----------------------------------------------------
    //-----------------------------------------------------------------------
    public boolean getUp (){
        return up;
    }
    public boolean getDown (){
        return down;
    }
    public boolean getLeft (){
        return left;
    }
    public boolean getRight (){
        return right;
    }
    public boolean getLMB (){
        return LMB;
    }
    public boolean getRMB (){
        return RMB;
    }
    public boolean getProcessed_click (){
        return processed_click;
    }
    public Vector2 getmouse_click_pos (){
        return mouse_click_pos;
    }
    public Vector2 getmap_click_pos (){
        return map_click_pos;
    }
    public boolean getDebug (){
        return debug;
    }
    public int getScreen_width (){
        return screen_width;
    }
    public int getScreen_height (){
        return screen_height;
    }
    //------------Setter-----------------------------------------------------
    //-----------------------------------------------------------------------
    public void setUp ( boolean up ){
        this.up = up;
    }
    public void setDown (boolean down){
        this.down = down;
    }
    public void setLeft ( boolean left ){
        this.left = left;
    }
    public void setRight (boolean right){
            this.right = right;
    }
    public void setLMB (boolean LMB){
        this.LMB = LMB;
    }
    public void setRMB (boolean RMB){
        this.RMB = RMB;
    }
    public void setProcessed_click (boolean processed_click){
        this.processed_click = processed_click;
    }
    public void getmouse_click_pos ( Vector2 pos ){
        this.mouse_click_pos = pos;
    }
    public void getmap_click_pos ( Vector2 pos ){
        this.map_click_pos = pos;
    }
    public void setDebug ( boolean debug ){
        this.debug = debug;
    }
    public void setScreen_width ( int screen_width ){
        this.screen_width = screen_width;
    }
    public void setScreen_height ( int screen_height ){
        this.screen_height = screen_height;
    }

    public Control(int screen_width, int screen_height, OrthographicCamera camera){
        this.camera = camera;
        this.screen_width = screen_width;
        this.screen_height = screen_height;
    }

    private void setMouseClickedPos(int screenX, int screenY){
        // Set mouse position (flip screen Y)
        mouse_click_pos.set(screenX, screen_height - screenY);
        map_click_pos.set(get_map_coords(mouse_click_pos));
    }

    public Vector2 get_map_coords(Vector2 mouse_coords){
        Vector3 v3 = new Vector3(mouse_coords.x, screen_height - mouse_coords.y, 0);
        this.camera.unproject(v3);
        return new Vector2(v3.x,v3.y);
    }

    @Override
    public boolean keyDown(int keycode) {
        switch (keycode) {
            case Keys.DOWN: down = true; break;
            case Keys.UP: up = true; break;
            case Keys.LEFT: left = true; break;
            case Keys.RIGHT: right = true; break;
            case Keys.W: up = true; break;
            case Keys.A: left = true; break;
            case Keys.S: down = true; break;
            case Keys.D: right = true; break;
            case Keys.ESCAPE: PauseManager.togglePause(); break; // ADD THIS LINE
            case Keys.BACKSPACE: debug = !debug; break;
        }
        return false;
    }


    @Override
    public boolean keyUp(int keycode) {
        switch (keycode) {
            case Keys.DOWN:
                down = false;
                break;
            case Keys.UP:
                up = false;
                break;
            case Keys.LEFT:
                left = false;
                break;
            case Keys.RIGHT:
                right = false;
                break;
            case Keys.W:
                up = false;
                break;
            case Keys.A:
                left = false;
                break;
            case Keys.S:
                down = false;
                break;
            case Keys.D:
                right = false;
                break;
            case Keys.ESCAPE:
                Gdx.app.exit();
                break;
            case Keys.BACKSPACE:
                debug = !debug;
                break;
        }
        return false;
    }

    @Override
    public boolean keyTyped(char character) {
        return false;
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
        if(pointer == 0 && button == 0){
            LMB = true;
        } else if (pointer == 0 && button == 0){
            RMB = true;
        }

        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
        if(pointer == 0 && button == 0){
            LMB = false;
            processed_click = false;
        } else if (pointer == 0 && button == 0){
            RMB = false;
        }

        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {
        setMouseClickedPos(screenX, screenY);
        return false;
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
        return false;
    }



}
/**
Notes on how to use class
-- from tutorial game on lib gdx with this class
-- Integration with this class in the driver for tutorial game
if (keyPress.getRight()) {
    bucketSprite.translateX(speed * delta);
    }
    private void input() {

        float speed = 4f;
        float delta = Gdx.graphics.getDeltaTime();
        //Gdx.input.isKeyPressed(Input.Keys.RIGHT)
        if (keyPress.getRight()) {
            bucketSprite.translateX(speed * delta);

            //Gdx.input.isKeyPressed((Keys.LEFT))
        } else if (keyPress.getLeft()) {
            bucketSprite.translateX((-speed * delta));
        }
        else if (keyPress.getUp()){
            bucketSprite.translateY(speed * delta);
        }
        else if (keyPress.getDown()){
            bucketSprite.translateY((-speed * delta));
        }
        * did not get integrated
        if (Gdx.input.isTouched()) {
            touchPos.set(Gdx.input.getX(), Gdx.input.getY());
            viewport.unproject(touchPos);
            bucketSprite.setCenterX(touchPos.x);
        }
    }
 */

